/*
Copyright 2026 Benny Powers. All rights reserved.
Use of this source code is governed by the GPLv3
license that can be found in the LICENSE file.
*/

// Package scss provides SCSS variable formatting for design tokens.
package scss

import (
	"fmt"
	"regexp"
	"sort"
	"strings"

	"bennypowers.dev/asimonim/convert/formatter"
	"bennypowers.dev/asimonim/token"
)

// secondsDurationPattern matches duration values like "2s", "0.5s", "-1.5s".
var secondsDurationPattern = regexp.MustCompile(`^[+-]?\d+(\.\d+)?s$`)

// Formatter outputs SCSS variables with kebab-case names.
type Formatter struct{}

// New creates a new SCSS formatter.
func New() *Formatter {
	return &Formatter{}
}

// Format converts tokens to SCSS variables.
func (f *Formatter) Format(tokens []*token.Token, opts formatter.Options) ([]byte, error) {
	var sb strings.Builder

	// Add header if provided, otherwise use default
	if opts.Header != "" {
		sb.WriteString(formatter.FormatHeader(opts.Header, formatter.SCSSComments))
	} else {
		sb.WriteString("// Generated by asimonim\n")
		sb.WriteString("// Do not edit manually\n\n")
	}

	groups := make(map[string][]*token.Token)
	for _, tok := range tokens {
		if len(tok.Path) > 0 {
			groups[tok.Path[0]] = append(groups[tok.Path[0]], tok)
		}
	}

	var groupNames []string
	for name := range groups {
		groupNames = append(groupNames, name)
	}
	sort.Strings(groupNames)

	for _, groupName := range groupNames {
		group := groups[groupName]
		sb.WriteString(fmt.Sprintf("// %s\n", formatter.ToTitleCase(groupName)))

		sorted := formatter.SortTokens(group)
		for _, tok := range sorted {
			baseName := formatter.ToKebabCase(strings.Join(tok.Path, "-"))
			name := formatter.ApplyPrefix(baseName, opts.Prefix, "-")
			value := formatter.ResolvedValue(tok)
			scssValue := toSCSSValue(tok.Type, value)

			if tok.Description != "" {
				sb.WriteString(fmt.Sprintf("/// %s\n", tok.Description))
			}
			sb.WriteString(fmt.Sprintf("$%s: %s;\n", name, scssValue))
		}
		sb.WriteString("\n")
	}

	return []byte(sb.String()), nil
}

func toSCSSValue(tokenType string, value any) string {
	switch tokenType {
	case token.TypeColor:
		return fmt.Sprintf("%v", value)
	case token.TypeDimension:
		return fmt.Sprintf("%v", value)
	case token.TypeNumber, token.TypeFontWeight:
		switch v := value.(type) {
		case float64:
			if v == float64(int(v)) {
				return fmt.Sprintf("%d", int(v))
			}
			return fmt.Sprintf("%g", v)
		case int:
			return fmt.Sprintf("%d", v)
		}
		return fmt.Sprintf("%v", value)
	case token.TypeFontFamily:
		if s, ok := value.(string); ok {
			return fmt.Sprintf("%q", s)
		}
	}

	if s, ok := value.(string); ok {
		if strings.HasPrefix(s, "#") || strings.HasSuffix(s, "px") ||
			strings.HasSuffix(s, "rem") || strings.HasSuffix(s, "em") ||
			strings.HasSuffix(s, "%") || strings.HasSuffix(s, "ms") ||
			secondsDurationPattern.MatchString(s) {
			return s
		}
	}

	return fmt.Sprintf("%v", value)
}
