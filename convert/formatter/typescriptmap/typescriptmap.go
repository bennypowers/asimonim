/*
Copyright 2026 Benny Powers. All rights reserved.
Use of this source code is governed by the GPLv3
license that can be found in the LICENSE file.
*/

// Package typescriptmap provides a TypeScript formatter with a typed TokenMap class.
package typescriptmap

import (
	"encoding/json"
	"fmt"
	"strings"

	"bennypowers.dev/asimonim/convert/formatter"
	"bennypowers.dev/asimonim/convert/formatter/typescript"
	"bennypowers.dev/asimonim/parser/common"
	"bennypowers.dev/asimonim/token"
)

// Formatter outputs TypeScript with a typed TokenMap class.
type Formatter struct{}

// New creates a new TypeScript Map formatter.
func New() *Formatter {
	return &Formatter{}
}

// Format converts tokens to TypeScript with TokenMap class.
func (f *Formatter) Format(tokens []*token.Token, opts formatter.Options) ([]byte, error) {
	var sb strings.Builder
	sb.WriteString("// Generated by asimonim\n")
	sb.WriteString("// Do not edit manually\n\n")

	// Write type definitions
	writeTypeDefinitions(&sb)
	sb.WriteString("\n")

	sorted := formatter.SortTokens(tokens)

	// Write TokenName union type
	writeTokenNameType(&sb, sorted, opts)
	sb.WriteString("\n")

	// Write token map entries
	writeTokenMap(&sb, sorted, opts)

	return []byte(sb.String()), nil
}

// buildCSSVarName constructs a CSS variable name like --rh-color-blue.
func buildCSSVarName(tok *token.Token, opts formatter.Options) string {
	name := strings.Join(tok.Path, "-")
	if opts.Prefix != "" {
		name = opts.Prefix + "-" + name
	}
	return "--" + name
}

// buildDotPath constructs a dot-separated path like color.blue (no prefix).
func buildDotPath(tok *token.Token) string {
	return strings.Join(tok.Path, ".")
}

// writeTypeDefinitions writes the common type interfaces.
func writeTypeDefinitions(sb *strings.Builder) {
	sb.WriteString(`/**
 * Represents a color value in DTCG 2025.10 format.
 * @see https://design-tokens.github.io/community-group/format/#color
 */
export interface Color {
  colorSpace: string;
  components: (number | "none")[];
  alpha?: number;
  hex?: string;
}

/**
 * Represents a dimension value with numeric value and unit.
 */
export interface Dimension {
  value: number;
  unit: string;
}

/**
 * Represents a design token with its value and metadata.
 */
export interface DesignToken<V> {
  $value: V;
  $type?: string;
  $description?: string;
}
`)
}

// writeTokenNameType writes the TokenName union type with both CSS var and dot-path keys.
func writeTokenNameType(sb *strings.Builder, tokens []*token.Token, opts formatter.Options) {
	sb.WriteString("/**\n * Union type of all token names (CSS variable or dot-path).\n */\n")

	if len(tokens) == 0 {
		sb.WriteString("export type TokenName = never;\n")
		return
	}

	sb.WriteString("export type TokenName =\n")
	for i, tok := range tokens {
		cssVar := buildCSSVarName(tok, opts)
		dotPath := buildDotPath(tok)
		fmt.Fprintf(sb, "  | \"%s\"\n", cssVar)
		if i == len(tokens)-1 {
			fmt.Fprintf(sb, "  | \"%s\";\n", dotPath)
		} else {
			fmt.Fprintf(sb, "  | \"%s\"\n", dotPath)
		}
	}
}

// writeTokenMap writes the TokenMap class with typed get() overloads.
func writeTokenMap(sb *strings.Builder, tokens []*token.Token, opts formatter.Options) {
	// Write .get() overloads
	sb.WriteString("/**\n * Typed map for accessing design tokens by CSS variable name or dot-path.\n */\n")
	sb.WriteString("export class TokenMap {\n")
	sb.WriteString("  private readonly tokens: Map<TokenName, DesignToken<unknown>>;\n\n")
	sb.WriteString("  constructor() {\n")
	sb.WriteString("    this.tokens = new Map();\n")

	// Populate the map with both CSS var and dot-path keys
	for _, tok := range tokens {
		cssVar := buildCSSVarName(tok, opts)
		dotPath := buildDotPath(tok)
		value := formatValue(tok)
		fmt.Fprintf(sb, "    this.tokens.set(\"%s\", %s);\n", cssVar, value)
		fmt.Fprintf(sb, "    this.tokens.set(\"%s\", this.tokens.get(\"%s\")!);\n", dotPath, cssVar)
	}

	sb.WriteString("  }\n\n")

	// Write typed get() overloads for both key types
	for _, tok := range tokens {
		cssVar := buildCSSVarName(tok, opts)
		dotPath := buildDotPath(tok)
		valueType := inferValueType(tok)

		if tok.Description != "" {
			sb.WriteString(typescript.FormatJSDoc(tok.Description))
		}
		fmt.Fprintf(sb, "  get(name: \"%s\"): DesignToken<%s>;\n", cssVar, valueType)
		fmt.Fprintf(sb, "  get(name: \"%s\"): DesignToken<%s>;\n", dotPath, valueType)
	}

	// Generic fallback overload
	sb.WriteString("  get(name: TokenName): DesignToken<unknown>;\n")
	sb.WriteString("  get(name: TokenName): DesignToken<unknown> {\n")
	sb.WriteString("    const token = this.tokens.get(name);\n")
	sb.WriteString("    if (!token) {\n")
	sb.WriteString("      throw new Error(`Token \"${name}\" not found`);\n")
	sb.WriteString("    }\n")
	sb.WriteString("    return token;\n")
	sb.WriteString("  }\n\n")

	// Add has() method
	sb.WriteString("  has(name: TokenName): boolean {\n")
	sb.WriteString("    return this.tokens.has(name);\n")
	sb.WriteString("  }\n\n")

	// Add keys() method
	sb.WriteString("  keys(): IterableIterator<TokenName> {\n")
	sb.WriteString("    return this.tokens.keys();\n")
	sb.WriteString("  }\n")

	sb.WriteString("}\n\n")

	// Export a default instance
	sb.WriteString("/**\n * Default token map instance.\n */\n")
	sb.WriteString("export const tokens = new TokenMap();\n")
}

// formatValue formats a token value for TypeScript output.
func formatValue(tok *token.Token) string {
	value := formatter.ResolvedValue(tok)

	result := map[string]any{
		"$value": formatTypedValue(tok, value),
	}

	if tok.Type != "" {
		result["$type"] = tok.Type
	}
	if tok.Description != "" {
		result["$description"] = tok.Description
	}

	data, err := json.MarshalIndent(result, "    ", "  ")
	if err != nil {
		return "{}"
	}
	return string(data)
}

// formatTypedValue formats a value based on token type.
func formatTypedValue(tok *token.Token, value any) any {
	switch tok.Type {
	case token.TypeColor:
		// Try to parse as structured color
		if colorVal, err := common.ParseColorValue(value, tok.SchemaVersion); err == nil {
			if objColor, ok := colorVal.(*common.ObjectColorValue); ok {
				result := map[string]any{
					"colorSpace": objColor.ColorSpace,
					"components": objColor.Components,
				}
				if objColor.Alpha != nil {
					result["alpha"] = *objColor.Alpha
				}
				if objColor.Hex != nil {
					result["hex"] = *objColor.Hex
				}
				return result
			}
		}
		// For string colors, return as-is
		return value

	case token.TypeDimension:
		// Check if it's already a structured dimension
		if m, ok := value.(map[string]any); ok {
			if _, hasValue := m["value"]; hasValue {
				if _, hasUnit := m["unit"]; hasUnit {
					return m
				}
			}
		}
		return value

	default:
		return value
	}
}

// inferValueType infers the TypeScript type for a token value.
func inferValueType(tok *token.Token) string {
	switch tok.Type {
	case token.TypeColor:
		// Check if it's a structured color
		value := formatter.ResolvedValue(tok)
		if _, err := common.ParseColorValue(value, tok.SchemaVersion); err == nil {
			return "Color"
		}
		if _, ok := value.(map[string]any); ok {
			return "Color"
		}
		return "string"

	case token.TypeDimension:
		value := formatter.ResolvedValue(tok)
		if m, ok := value.(map[string]any); ok {
			if _, hasValue := m["value"]; hasValue {
				if _, hasUnit := m["unit"]; hasUnit {
					return "Dimension"
				}
			}
		}
		return "string"

	case token.TypeNumber, token.TypeFontWeight:
		return "number"

	case token.TypeCubicBezier:
		return "[number, number, number, number]"

	case token.TypeFontFamily:
		value := formatter.ResolvedValue(tok)
		if _, ok := value.([]any); ok {
			return "string[]"
		}
		return "string"

	case token.TypeDuration:
		value := formatter.ResolvedValue(tok)
		if _, ok := value.(map[string]any); ok {
			return "{ value: number; unit: string }"
		}
		return "string"

	case token.TypeShadow:
		return "{ offsetX: Dimension | string; offsetY: Dimension | string; blur: Dimension | string; spread?: Dimension | string; color: Color | string }"

	case token.TypeBorder:
		return "{ width: Dimension | string; style: string; color: Color | string }"

	case token.TypeTypography:
		return "{ fontFamily?: string | string[]; fontSize?: Dimension | string; fontWeight?: number | string; lineHeight?: number | string; letterSpacing?: Dimension | string }"

	case token.TypeTransition:
		return "{ duration: { value: number; unit: string } | string; timingFunction: [number, number, number, number] | string; delay?: { value: number; unit: string } | string }"

	case token.TypeGradient:
		return "{ type: string; stops: { color: Color | string; position: number }[] }"

	case token.TypeStrokeStyle:
		value := formatter.ResolvedValue(tok)
		if _, ok := value.(map[string]any); ok {
			return "{ dashArray: Dimension[]; lineCap?: string }"
		}
		return "string"

	default:
		value := formatter.ResolvedValue(tok)
		switch value.(type) {
		case string:
			return "string"
		case float64:
			return "number"
		case int:
			return "number"
		case bool:
			return "boolean"
		case []any:
			return "unknown[]"
		case map[string]any:
			return "Record<string, unknown>"
		default:
			return "unknown"
		}
	}
}
