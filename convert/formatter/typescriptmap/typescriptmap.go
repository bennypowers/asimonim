/*
Copyright 2026 Benny Powers. All rights reserved.
Use of this source code is governed by the GPLv3
license that can be found in the LICENSE file.
*/

// Package typescriptmap provides a TypeScript formatter with a typed TokenMap class.
package typescriptmap

import (
	"encoding/json"
	"fmt"
	"strings"

	"bennypowers.dev/asimonim/convert/formatter"
	"bennypowers.dev/asimonim/parser/common"
	"bennypowers.dev/asimonim/token"
)

// Formatter outputs TypeScript with a typed TokenMap class.
type Formatter struct{}

// New creates a new TypeScript Map formatter.
func New() *Formatter {
	return &Formatter{}
}

// Format converts tokens to TypeScript with TokenMap class.
func (f *Formatter) Format(tokens []*token.Token, opts formatter.Options) ([]byte, error) {
	var sb strings.Builder
	sb.WriteString("// Generated by asimonim\n")
	sb.WriteString("// Do not edit manually\n\n")

	// Write type definitions
	writeTypeDefinitions(&sb)
	sb.WriteString("\n")

	sorted := formatter.SortTokens(tokens)

	// Write TokenName union type
	writeTokenNameType(&sb, sorted, opts)
	sb.WriteString("\n")

	// Write token map entries
	writeTokenMap(&sb, sorted, opts)

	return []byte(sb.String()), nil
}

// buildCSSVarName constructs a CSS variable name like --rh-color-blue.
func buildCSSVarName(tok *token.Token, opts formatter.Options) string {
	name := strings.Join(tok.Path, "-")
	if opts.Prefix != "" {
		name = opts.Prefix + "-" + name
	}
	return "--" + name
}

// buildDotPath constructs a dot-separated path like color.blue (no prefix).
func buildDotPath(tok *token.Token) string {
	return strings.Join(tok.Path, ".")
}

// escapeTS escapes a string for use in a TypeScript double-quoted string literal.
// It escapes backslashes, double quotes, and control characters.
func escapeTS(s string) string {
	var sb strings.Builder
	for _, r := range s {
		switch r {
		case '\\':
			sb.WriteString(`\\`)
		case '"':
			sb.WriteString(`\"`)
		case '\n':
			sb.WriteString(`\n`)
		case '\r':
			sb.WriteString(`\r`)
		case '\t':
			sb.WriteString(`\t`)
		default:
			sb.WriteRune(r)
		}
	}
	return sb.String()
}

// writeTypeDefinitions writes the common type interfaces.
func writeTypeDefinitions(sb *strings.Builder) {
	sb.WriteString(`/**
 * Represents a color value in DTCG 2025.10 format.
 * @see https://design-tokens.github.io/community-group/format/#color
 */
export interface Color {
  colorSpace: string;
  components: (number | "none")[];
  alpha?: number;
  hex?: string;
}

/**
 * Represents a dimension value with numeric value and unit.
 */
export interface Dimension {
  value: number;
  unit: string;
}

/**
 * Represents a design token with its value and metadata.
 */
export interface DesignToken<V> {
  $value: V;
  $type?: string;
  $description?: string;
}
`)
}

// writeTokenNameType writes the TokenName union type with both CSS var and dot-path keys.
func writeTokenNameType(sb *strings.Builder, tokens []*token.Token, opts formatter.Options) {
	sb.WriteString("/**\n * Union type of all token names (CSS variable or dot-path).\n */\n")

	if len(tokens) == 0 {
		sb.WriteString("export type TokenName = never;\n")
		return
	}

	sb.WriteString("export type TokenName =\n")
	for i, tok := range tokens {
		cssVar := escapeTS(buildCSSVarName(tok, opts))
		dotPath := escapeTS(buildDotPath(tok))
		fmt.Fprintf(sb, "  | \"%s\"\n", cssVar)
		if i == len(tokens)-1 {
			fmt.Fprintf(sb, "  | \"%s\";\n", dotPath)
		} else {
			fmt.Fprintf(sb, "  | \"%s\"\n", dotPath)
		}
	}
}

// writeTokenMap writes the generic TokenMap class.
func writeTokenMap(sb *strings.Builder, tokens []*token.Token, opts formatter.Options) {
	// Write generic TokenMap class - type safety comes from entries object
	sb.WriteString("/**\n * Typed map for accessing design tokens by CSS variable name or dot-path.\n */\n")
	sb.WriteString("export class TokenMap<T extends Record<string, DesignToken<unknown>>> {\n")
	sb.WriteString("  #map: Map<string, DesignToken<unknown>>;\n\n")
	sb.WriteString("  get size(): number { return this.#map.size; }\n")
	sb.WriteString("  [Symbol.iterator]() { return this.#map[Symbol.iterator](); }\n\n")
	sb.WriteString("  constructor(\n")
	sb.WriteString("    entries: T,\n")
	sb.WriteString("    prefix = \"\",\n")
	sb.WriteString("    delimiter = \"-\"\n")
	sb.WriteString("  ) {\n")
	sb.WriteString("    this.#map = new Map(Object.entries(entries));\n")
	sb.WriteString("    // Add dot-path aliases\n")
	sb.WriteString("    for (const [key, value] of this.#map) {\n")
	sb.WriteString("      if (key.startsWith(\"--\")) {\n")
	sb.WriteString("        let path = key.slice(2);\n")
	sb.WriteString("        if (prefix && path.startsWith(prefix + delimiter)) {\n")
	sb.WriteString("          path = path.slice(prefix.length + delimiter.length);\n")
	sb.WriteString("        }\n")
	sb.WriteString("        const dotPath = path.split(delimiter).join(\".\");\n")
	sb.WriteString("        this.#map.set(dotPath, value);\n")
	sb.WriteString("      }\n")
	sb.WriteString("    }\n")
	sb.WriteString("  }\n\n")

	// Generic get/has methods - type inference from T
	sb.WriteString("  get<K extends keyof T>(name: K): T[K];\n")
	sb.WriteString("  get(name: string): DesignToken<unknown> | undefined;\n")
	sb.WriteString("  get(name: string): DesignToken<unknown> | undefined {\n")
	sb.WriteString("    return this.#map.get(name);\n")
	sb.WriteString("  }\n\n")

	sb.WriteString("  has<K extends keyof T>(name: K): true;\n")
	sb.WriteString("  has(name: string): boolean;\n")
	sb.WriteString("  has(name: string): boolean { return this.#map.has(name); }\n\n")

	// Add iterator methods
	sb.WriteString("  keys() { return this.#map.keys(); }\n")
	sb.WriteString("  values() { return this.#map.values(); }\n")
	sb.WriteString("  entries() { return this.#map.entries(); }\n")
	sb.WriteString("  forEach(fn: (value: DesignToken<unknown>, key: string, map: TokenMap<T>) => void, thisArg?: unknown): void {\n")
	sb.WriteString("    this.#map.forEach((v, k) => { fn.call(thisArg, v, k, this); });\n")
	sb.WriteString("  }\n")

	sb.WriteString("}\n\n")

	// Build token entries object with type annotations for inference
	sb.WriteString("/**\n * Default token map instance.\n */\n")
	sb.WriteString("export const tokens = new TokenMap({\n")
	for _, tok := range tokens {
		cssVar := escapeTS(buildCSSVarName(tok, opts))
		value := formatValue(tok)
		valueType := inferValueType(tok)
		fmt.Fprintf(sb, "  \"%s\": %s as DesignToken<%s>,\n", cssVar, value, valueType)
	}
	// Pass prefix and delimiter to constructor
	prefix := escapeTS(opts.Prefix)
	delimiter := opts.Delimiter
	if delimiter == "" {
		delimiter = "-"
	}
	fmt.Fprintf(sb, "}, \"%s\", \"%s\");\n", prefix, escapeTS(delimiter))
}

// formatValue formats a token value for TypeScript output.
func formatValue(tok *token.Token) string {
	value := formatter.ResolvedValue(tok)

	result := map[string]any{
		"$value": formatTypedValue(tok, value),
	}

	if tok.Type != "" {
		result["$type"] = tok.Type
	}
	if tok.Description != "" {
		result["$description"] = tok.Description
	}

	data, err := json.MarshalIndent(result, "    ", "  ")
	if err != nil {
		return "{}"
	}
	return string(data)
}

// formatTypedValue formats a value based on token type.
func formatTypedValue(tok *token.Token, value any) any {
	switch tok.Type {
	case token.TypeColor:
		// Try to parse as structured color
		if colorVal, err := common.ParseColorValue(value, tok.SchemaVersion); err == nil {
			if objColor, ok := colorVal.(*common.ObjectColorValue); ok {
				result := map[string]any{
					"colorSpace": objColor.ColorSpace,
					"components": objColor.Components,
				}
				if objColor.Alpha != nil {
					result["alpha"] = *objColor.Alpha
				}
				if objColor.Hex != nil {
					result["hex"] = *objColor.Hex
				}
				return result
			}
		}
		// For string colors, return as-is
		return value

	case token.TypeDimension:
		// Check if it's already a structured dimension
		if m, ok := value.(map[string]any); ok {
			if _, hasValue := m["value"]; hasValue {
				if _, hasUnit := m["unit"]; hasUnit {
					return m
				}
			}
		}
		return value

	default:
		return value
	}
}

// inferValueType infers the TypeScript type for a token value.
func inferValueType(tok *token.Token) string {
	switch tok.Type {
	case token.TypeColor:
		// Check if it's a structured color
		value := formatter.ResolvedValue(tok)
		if _, err := common.ParseColorValue(value, tok.SchemaVersion); err == nil {
			return "Color"
		}
		if _, ok := value.(map[string]any); ok {
			return "Color"
		}
		return "string"

	case token.TypeDimension:
		value := formatter.ResolvedValue(tok)
		if m, ok := value.(map[string]any); ok {
			if _, hasValue := m["value"]; hasValue {
				if _, hasUnit := m["unit"]; hasUnit {
					return "Dimension"
				}
			}
		}
		return "string"

	case token.TypeNumber, token.TypeFontWeight:
		return "number"

	case token.TypeCubicBezier:
		return "[number, number, number, number]"

	case token.TypeFontFamily:
		value := formatter.ResolvedValue(tok)
		if _, ok := value.([]any); ok {
			return "string[]"
		}
		return "string"

	case token.TypeDuration:
		value := formatter.ResolvedValue(tok)
		if _, ok := value.(map[string]any); ok {
			return "{ value: number; unit: string }"
		}
		return "string"

	case token.TypeShadow:
		return "{ offsetX: Dimension | string; offsetY: Dimension | string; blur: Dimension | string; spread?: Dimension | string; color: Color | string }"

	case token.TypeBorder:
		return "{ width: Dimension | string; style: string; color: Color | string }"

	case token.TypeTypography:
		return "{ fontFamily?: string | string[]; fontSize?: Dimension | string; fontWeight?: number | string; lineHeight?: number | string; letterSpacing?: Dimension | string }"

	case token.TypeTransition:
		return "{ duration: { value: number; unit: string } | string; timingFunction: [number, number, number, number] | string; delay?: { value: number; unit: string } | string }"

	case token.TypeGradient:
		return "{ type: string; stops: { color: Color | string; position: number }[] }"

	case token.TypeStrokeStyle:
		value := formatter.ResolvedValue(tok)
		if _, ok := value.(map[string]any); ok {
			return "{ dashArray: Dimension[]; lineCap?: string }"
		}
		return "string"

	default:
		value := formatter.ResolvedValue(tok)
		switch value.(type) {
		case string:
			return "string"
		case float64:
			return "number"
		case int:
			return "number"
		case bool:
			return "boolean"
		case []any:
			return "unknown[]"
		case map[string]any:
			return "Record<string, unknown>"
		default:
			return "unknown"
		}
	}
}
