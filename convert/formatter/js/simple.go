/*
Copyright 2026 Benny Powers. All rights reserved.
Use of this source code is governed by the GPLv3
license that can be found in the LICENSE file.
*/

package js

import (
	"encoding/json"
	"fmt"
	"strings"

	"bennypowers.dev/asimonim/convert/formatter"
	"bennypowers.dev/asimonim/token"
)

// formatSimple generates simple const exports.
func (f *Formatter) formatSimple(tokens []*token.Token, opts formatter.Options) ([]byte, error) {
	var sb strings.Builder

	// Add header if provided, otherwise use default
	if opts.Header != "" {
		sb.WriteString(formatter.FormatHeader(opts.Header, formatter.CStyleComments))
	} else {
		sb.WriteString("// Generated by asimonim\n")
		sb.WriteString("// Do not edit manually\n\n")
	}

	sorted := formatter.SortTokens(tokens)

	for _, tok := range sorted {
		baseName := formatter.ToCamelCase(strings.Join(tok.Path, "-"))
		name := formatter.ApplyPrefixCamel(baseName, opts.Prefix)
		value := formatter.ResolvedValue(tok)
		jsValue := ToValue(value)

		// Write description comment
		if tok.Description != "" {
			sb.WriteString(f.formatDescription(tok.Description, value))
		}

		// Write export
		sb.WriteString(f.formatExport(name, jsValue))
	}

	return []byte(sb.String()), nil
}

// formatDescription formats a token description as a comment.
// For JSDoc types, it includes the type annotation.
func (f *Formatter) formatDescription(desc string, value any) string {
	if f.opts.Types == TypesJSDoc {
		return formatJSDocWithType(desc, inferJSDocType(value))
	}
	return FormatJSDoc(desc)
}

// formatExport formats an export statement based on module and type options.
// For TypeScript (.ts/.cts), we use `export const x = y as const;` which
// provides proper type narrowing. TypeScript handles CJS transpilation
// when the file extension is .cts.
func (f *Formatter) formatExport(name, value string) string {
	switch {
	case f.opts.Types == TypesTS:
		// TypeScript: use `as const` for type narrowing (works in both .ts and .cts)
		return fmt.Sprintf("export const %s = %s as const;\n", name, value)
	case f.opts.Module == ModuleCJS:
		// JavaScript CJS: use exports assignment
		return fmt.Sprintf("exports.%s = %s;\n", name, value)
	default:
		// JavaScript ESM: use export const
		return fmt.Sprintf("export const %s = %s;\n", name, value)
	}
}

// ToValue converts a value to JavaScript/TypeScript literal syntax.
func ToValue(value any) string {
	switch v := value.(type) {
	case nil:
		return "null"
	case string:
		return fmt.Sprintf("%q", v)
	case float64:
		if v == float64(int(v)) {
			return fmt.Sprintf("%d", int(v))
		}
		return fmt.Sprintf("%g", v)
	case int:
		return fmt.Sprintf("%d", v)
	case bool:
		return fmt.Sprintf("%t", v)
	case []any, map[string]any:
		// Marshal complex types as JSON literals
		data, err := json.Marshal(v)
		if err != nil {
			return fmt.Sprintf("%q", fmt.Sprintf("%v", v))
		}
		return string(data)
	default:
		// Fallback: marshal as JSON if possible
		data, err := json.Marshal(v)
		if err != nil {
			return fmt.Sprintf("%q", fmt.Sprintf("%v", v))
		}
		return string(data)
	}
}

// FormatJSDoc formats a description as a valid JSDoc comment.
// Handles multi-line descriptions and escapes "*/" to prevent comment breakage.
func FormatJSDoc(desc string) string {
	// Escape */ to prevent premature comment closing
	desc = strings.ReplaceAll(desc, "*/", "*\\/")

	if !strings.Contains(desc, "\n") {
		return fmt.Sprintf("/** %s */\n", desc)
	}

	// Multi-line JSDoc
	var sb strings.Builder
	sb.WriteString("/**\n")
	for _, line := range strings.Split(desc, "\n") {
		sb.WriteString(fmt.Sprintf(" * %s\n", line))
	}
	sb.WriteString(" */\n")
	return sb.String()
}

// formatJSDocWithType formats a description with a @type annotation.
func formatJSDocWithType(desc, jsType string) string {
	// Escape */ to prevent premature comment closing
	desc = strings.ReplaceAll(desc, "*/", "*\\/")

	if desc == "" {
		return fmt.Sprintf("/** @type {%s} */\n", jsType)
	}

	if !strings.Contains(desc, "\n") {
		return fmt.Sprintf("/**\n * %s\n * @type {%s}\n */\n", desc, jsType)
	}

	// Multi-line JSDoc
	var sb strings.Builder
	sb.WriteString("/**\n")
	for _, line := range strings.Split(desc, "\n") {
		sb.WriteString(fmt.Sprintf(" * %s\n", line))
	}
	sb.WriteString(fmt.Sprintf(" * @type {%s}\n", jsType))
	sb.WriteString(" */\n")
	return sb.String()
}

// inferJSDocType infers a JSDoc type from a value.
func inferJSDocType(value any) string {
	switch value.(type) {
	case string:
		return "string"
	case float64, int:
		return "number"
	case bool:
		return "boolean"
	case []any:
		return "Array"
	case map[string]any:
		return "Object"
	default:
		return "unknown"
	}
}
