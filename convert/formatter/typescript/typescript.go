/*
Copyright 2026 Benny Powers. All rights reserved.
Use of this source code is governed by the GPLv3
license that can be found in the LICENSE file.
*/

// Package typescript provides TypeScript ESM formatting for design tokens.
package typescript

import (
	"fmt"
	"strings"

	"bennypowers.dev/asimonim/convert/formatter"
	"bennypowers.dev/asimonim/token"
)

// Formatter outputs TypeScript ESM with camelCase exports.
type Formatter struct{}

// New creates a new TypeScript formatter.
func New() *Formatter {
	return &Formatter{}
}

// Format converts tokens to TypeScript ESM format.
func (f *Formatter) Format(tokens []*token.Token, opts formatter.Options) ([]byte, error) {
	var sb strings.Builder
	sb.WriteString("// Generated by asimonim\n")
	sb.WriteString("// Do not edit manually\n\n")

	sorted := formatter.SortTokens(tokens)

	for _, tok := range sorted {
		baseName := formatter.ToCamelCase(strings.Join(tok.Path, "-"))
		name := formatter.ApplyPrefixCamel(baseName, opts.Prefix)
		value := formatter.ResolvedValue(tok)
		tsValue := ToValue(value)

		if tok.Description != "" {
			sb.WriteString(fmt.Sprintf("/** %s */\n", tok.Description))
		}
		sb.WriteString(fmt.Sprintf("export const %s = %s as const;\n", name, tsValue))
	}

	return []byte(sb.String()), nil
}

// ToValue converts a value to TypeScript literal syntax.
func ToValue(value any) string {
	switch v := value.(type) {
	case string:
		return fmt.Sprintf("%q", v)
	case float64:
		if v == float64(int(v)) {
			return fmt.Sprintf("%d", int(v))
		}
		return fmt.Sprintf("%g", v)
	case int:
		return fmt.Sprintf("%d", v)
	case bool:
		return fmt.Sprintf("%t", v)
	default:
		return fmt.Sprintf("%q", fmt.Sprintf("%v", v))
	}
}
