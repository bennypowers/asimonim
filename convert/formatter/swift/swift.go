/*
Copyright 2026 Benny Powers. All rights reserved.
Use of this source code is governed by the GPLv3
license that can be found in the LICENSE file.
*/

// Package swift provides iOS Swift constant formatting for design tokens.
package swift

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/mazznoer/csscolorparser"

	"bennypowers.dev/asimonim/convert/formatter"
	"bennypowers.dev/asimonim/internal/logger"
	"bennypowers.dev/asimonim/token"
)

// Formatter outputs iOS Swift constants.
type Formatter struct{}

// New creates a new Swift formatter.
func New() *Formatter {
	return &Formatter{}
}

// Format converts tokens to Swift constants.
func (f *Formatter) Format(tokens []*token.Token, opts formatter.Options) ([]byte, error) {
	var sb strings.Builder
	sb.WriteString("import Foundation\n")
	sb.WriteString("import SwiftUI\n\n")
	sb.WriteString("// Generated by asimonim\n")
	sb.WriteString("// Do not edit manually\n\n")

	enumName := "DesignTokens"
	if opts.Prefix != "" {
		enumName = formatter.ToPascalCase(opts.Prefix) + "Tokens"
	}
	sb.WriteString(fmt.Sprintf("public enum %s {\n", enumName))

	groups := formatter.GroupByType(tokens)
	typeOrder := []string{
		token.TypeColor,
		token.TypeDimension,
		token.TypeFontFamily,
		token.TypeFontWeight,
		token.TypeDuration,
		token.TypeCubicBezier,
		token.TypeNumber,
		token.TypeString,
	}

	for _, tokenType := range typeOrder {
		group, exists := groups[tokenType]
		if !exists || len(group) == 0 {
			continue
		}

		sb.WriteString(fmt.Sprintf("\n    // MARK: - %s\n", formatter.ToTitleCase(tokenType)))
		sb.WriteString(fmt.Sprintf("    public enum %s {\n", formatter.ToPascalCase(tokenType)))

		sorted := formatter.SortTokens(group)
		for _, tok := range sorted {
			name := formatter.ToCamelCase(strings.Join(tok.Path, "-"))
			value := formatter.ResolvedValue(tok)
			swiftValue := toSwiftValue(tok.Type, value)

			if tok.Description != "" {
				sb.WriteString(fmt.Sprintf("        /// %s\n", tok.Description))
			}
			sb.WriteString(fmt.Sprintf("        public static let %s = %s\n", name, swiftValue))
		}

		sb.WriteString("    }\n")
	}

	if ungrouped, exists := groups[""]; exists && len(ungrouped) > 0 {
		sb.WriteString("\n    // MARK: - Other\n")
		sb.WriteString("    public enum Other {\n")
		sorted := formatter.SortTokens(ungrouped)
		for _, tok := range sorted {
			name := formatter.ToCamelCase(strings.Join(tok.Path, "-"))
			value := formatter.ResolvedValue(tok)
			swiftValue := toSwiftValue(tok.Type, value)
			sb.WriteString(fmt.Sprintf("        public static let %s = %s\n", name, swiftValue))
		}
		sb.WriteString("    }\n")
	}

	sb.WriteString("}\n")
	return []byte(sb.String()), nil
}

func toSwiftValue(tokenType string, value any) string {
	switch tokenType {
	case token.TypeColor:
		if colorObj, ok := value.(map[string]any); ok {
			return structuredColorToSwift(colorObj)
		}
		if s, ok := value.(string); ok {
			c, err := csscolorparser.Parse(s)
			if err == nil {
				return formatSwiftColor(".sRGB", c.R, c.G, c.B, c.A)
			}
			return fmt.Sprintf("%q", s)
		}
	case token.TypeDimension:
		if s, ok := value.(string); ok {
			s = strings.TrimSuffix(s, "px")
			s = strings.TrimSuffix(s, "rem")
			s = strings.TrimSuffix(s, "em")
			return fmt.Sprintf("CGFloat(%s)", s)
		}
	case token.TypeDuration:
		if s, ok := value.(string); ok {
			var numStr string
			var isMilliseconds bool
			if strings.HasSuffix(s, "ms") {
				numStr = strings.TrimSuffix(s, "ms")
				isMilliseconds = true
			} else if strings.HasSuffix(s, "s") {
				numStr = strings.TrimSuffix(s, "s")
			} else {
				numStr = s
			}
			num, err := strconv.ParseFloat(numStr, 64)
			if err != nil {
				return fmt.Sprintf("TimeInterval(%s)", numStr)
			}
			if isMilliseconds {
				num = num / 1000.0
			}
			return fmt.Sprintf("TimeInterval(%g)", num)
		}
	case token.TypeNumber, token.TypeFontWeight:
		switch v := value.(type) {
		case float64:
			if v == float64(int(v)) {
				return fmt.Sprintf("%d", int(v))
			}
			return fmt.Sprintf("%g", v)
		case int:
			return fmt.Sprintf("%d", v)
		}
	}

	return fmt.Sprintf("%q", fmt.Sprintf("%v", value))
}

func structuredColorToSwift(colorObj map[string]any) string {
	colorSpace, _ := colorObj["colorSpace"].(string)
	componentsRaw, _ := colorObj["components"].([]any)
	alphaRaw := colorObj["alpha"]

	alpha := 1.0
	if a, ok := alphaRaw.(float64); ok {
		alpha = a
	}

	var components []float64
	for _, comp := range componentsRaw {
		if v, ok := comp.(float64); ok {
			components = append(components, v)
		}
	}

	if len(components) < 3 {
		logger.Warn("structured color has fewer than 3 components, using Color.clear")
		return "Color.clear"
	}

	swiftColorSpace := mapColorSpaceToSwift(colorSpace)
	return formatSwiftColor(swiftColorSpace, components[0], components[1], components[2], alpha)
}

func mapColorSpaceToSwift(dtcgColorSpace string) string {
	switch dtcgColorSpace {
	case "srgb", "":
		return ".sRGB"
	case "display-p3":
		return ".displayP3"
	case "srgb-linear", "linear-srgb":
		return ".linearSRGB"
	case "xyz", "xyz-d65":
		return ".genericXYZ"
	case "xyz-d50":
		return ".genericXYZ"
	case "lab", "lch", "oklab", "oklch":
		return ".sRGB"
	default:
		return ".sRGB"
	}
}

func formatSwiftColor(colorSpace string, r, g, b, a float64) string {
	if a < 0.999 {
		return fmt.Sprintf("Color(%s, red: %.4g, green: %.4g, blue: %.4g, opacity: %.4g)", colorSpace, r, g, b, a)
	}
	return fmt.Sprintf("Color(%s, red: %.4g, green: %.4g, blue: %.4g)", colorSpace, r, g, b)
}
