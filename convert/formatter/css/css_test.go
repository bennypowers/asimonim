/*
Copyright 2026 Benny Powers. All rights reserved.
Use of this source code is governed by the GPLv3
license that can be found in the LICENSE file.
*/

package css_test

import (
	"strings"
	"testing"

	"bennypowers.dev/asimonim/convert/formatter"
	"bennypowers.dev/asimonim/convert/formatter/css"
	"bennypowers.dev/asimonim/token"
)

func TestFormat_Plain(t *testing.T) {
	tokens := []*token.Token{
		{
			Name:        "color-primary",
			Path:        []string{"color", "primary"},
			Type:        token.TypeColor,
			Value:       "#FF6B35",
			Description: "Primary brand color",
		},
		{
			Name:  "spacing-small",
			Path:  []string{"spacing", "small"},
			Type:  token.TypeDimension,
			Value: "4px",
		},
	}

	f := css.New()
	result, err := f.Format(tokens, formatter.Options{})
	if err != nil {
		t.Fatalf("Format() error = %v", err)
	}

	output := string(result)

	// Check header
	if !strings.Contains(output, "/* Generated by asimonim */") {
		t.Error("expected header comment")
	}

	// Check :root selector
	if !strings.Contains(output, ":root {") {
		t.Error("expected :root selector")
	}

	// Check custom properties
	if !strings.Contains(output, "--color-primary: #FF6B35;") {
		t.Error("expected --color-primary custom property")
	}
	if !strings.Contains(output, "--spacing-small: 4px;") {
		t.Error("expected --spacing-small custom property")
	}

	// Check description comment
	if !strings.Contains(output, "/* Primary brand color */") {
		t.Error("expected description comment")
	}
}

func TestFormat_WithPrefix(t *testing.T) {
	tokens := []*token.Token{
		{
			Name:  "color-primary",
			Path:  []string{"color", "primary"},
			Type:  token.TypeColor,
			Value: "#FF6B35",
		},
	}

	f := css.New()
	result, err := f.Format(tokens, formatter.Options{Prefix: "rh"})
	if err != nil {
		t.Fatalf("Format() error = %v", err)
	}

	output := string(result)

	if !strings.Contains(output, "--rh-color-primary: #FF6B35;") {
		t.Error("expected prefixed custom property")
	}
}

func TestFormat_LitFlavor(t *testing.T) {
	tokens := []*token.Token{
		{
			Name:  "color-primary",
			Path:  []string{"color", "primary"},
			Type:  token.TypeColor,
			Value: "#FF6B35",
		},
	}

	f := css.NewWithFlavor(css.FlavorLit)
	result, err := f.Format(tokens, formatter.Options{})
	if err != nil {
		t.Fatalf("Format() error = %v", err)
	}

	output := string(result)

	// Check Lit import
	if !strings.Contains(output, "import { css } from 'lit';") {
		t.Error("expected Lit import")
	}

	// Check css template tag
	if !strings.Contains(output, "export default css`") {
		t.Error("expected css template tag export")
	}

	// Check :host selector (not :root for web components)
	if !strings.Contains(output, ":host {") {
		t.Error("expected :host selector for Lit")
	}

	// Check closing backtick
	if !strings.Contains(output, "`;") {
		t.Error("expected closing template backtick")
	}
}

func TestFormat_LightDark(t *testing.T) {
	tokens := []*token.Token{
		{
			Name:  "color-text-on-light",
			Path:  []string{"color", "text", "on-light"},
			Type:  token.TypeColor,
			Value: "#000000",
		},
		{
			Name:  "color-text-on-dark",
			Path:  []string{"color", "text", "on-dark"},
			Type:  token.TypeColor,
			Value: "#FFFFFF",
		},
	}

	f := css.NewWithOptions(css.Options{
		Flavor: css.FlavorPlain,
		LightDark: css.LightDarkConfig{
			Enabled:  true,
			Patterns: css.DefaultLightDarkPatterns(),
		},
	})
	result, err := f.Format(tokens, formatter.Options{})
	if err != nil {
		t.Fatalf("Format() error = %v", err)
	}

	output := string(result)

	// Should include the light and dark variants
	if !strings.Contains(output, "--color-text-on-light: #000000;") {
		t.Error("expected light variant property")
	}
	if !strings.Contains(output, "--color-text-on-dark: #FFFFFF;") {
		t.Error("expected dark variant property")
	}

	// Should include the light-dark() version
	if !strings.Contains(output, "--color-text: light-dark(var(--color-text-on-light), var(--color-text-on-dark));") {
		t.Error("expected light-dark() property")
	}
}

func TestFormat_LightDarkWithPrefix(t *testing.T) {
	tokens := []*token.Token{
		{
			Name:  "color-brand-on-light",
			Path:  []string{"color", "brand", "on-light"},
			Type:  token.TypeColor,
			Value: "#FF0000",
		},
		{
			Name:  "color-brand-on-dark",
			Path:  []string{"color", "brand", "on-dark"},
			Type:  token.TypeColor,
			Value: "#CC0000",
		},
	}

	f := css.NewWithOptions(css.Options{
		Flavor: css.FlavorPlain,
		LightDark: css.LightDarkConfig{
			Enabled:  true,
			Patterns: [][2]string{{"on-light", "on-dark"}},
		},
	})
	result, err := f.Format(tokens, formatter.Options{Prefix: "rh"})
	if err != nil {
		t.Fatalf("Format() error = %v", err)
	}

	output := string(result)

	// Should include prefixed light-dark()
	if !strings.Contains(output, "--rh-color-brand: light-dark(var(--rh-color-brand-on-light), var(--rh-color-brand-on-dark));") {
		t.Error("expected prefixed light-dark() property")
	}
}

func TestFormat_LightDarkCustomPatterns(t *testing.T) {
	tokens := []*token.Token{
		{
			Name:  "color-bg-light",
			Path:  []string{"color", "bg", "light"},
			Type:  token.TypeColor,
			Value: "#FFFFFF",
		},
		{
			Name:  "color-bg-dark",
			Path:  []string{"color", "bg", "dark"},
			Type:  token.TypeColor,
			Value: "#000000",
		},
	}

	f := css.NewWithOptions(css.Options{
		Flavor: css.FlavorPlain,
		LightDark: css.LightDarkConfig{
			Enabled:  true,
			Patterns: [][2]string{{"light", "dark"}},
		},
	})
	result, err := f.Format(tokens, formatter.Options{})
	if err != nil {
		t.Fatalf("Format() error = %v", err)
	}

	output := string(result)

	// Should detect custom pattern
	if !strings.Contains(output, "--color-bg: light-dark(var(--color-bg-light), var(--color-bg-dark));") {
		t.Error("expected light-dark() with custom pattern")
	}
}

func TestFormat_LightDarkDisabled(t *testing.T) {
	tokens := []*token.Token{
		{
			Name:  "color-text-on-light",
			Path:  []string{"color", "text", "on-light"},
			Type:  token.TypeColor,
			Value: "#000000",
		},
		{
			Name:  "color-text-on-dark",
			Path:  []string{"color", "text", "on-dark"},
			Type:  token.TypeColor,
			Value: "#FFFFFF",
		},
	}

	f := css.NewWithOptions(css.Options{
		Flavor: css.FlavorPlain,
		LightDark: css.LightDarkConfig{
			Enabled: false,
		},
	})
	result, err := f.Format(tokens, formatter.Options{})
	if err != nil {
		t.Fatalf("Format() error = %v", err)
	}

	output := string(result)

	// Should NOT include light-dark() when disabled
	if strings.Contains(output, "light-dark(") {
		t.Error("should not generate light-dark() when disabled")
	}
}

func TestToCSSValue_CubicBezier(t *testing.T) {
	value := []any{0.25, 0.1, 0.25, 1.0}
	result := css.ToCSSValue(token.TypeCubicBezier, value)

	expected := "cubic-bezier(0.25, 0.1, 0.25, 1)"
	if result != expected {
		t.Errorf("expected %q, got %q", expected, result)
	}
}

func TestToCSSValue_FontFamily(t *testing.T) {
	result := css.ToCSSValue(token.TypeFontFamily, "Open Sans")
	expected := `"Open Sans"`
	if result != expected {
		t.Errorf("expected %q, got %q", expected, result)
	}

	// Already quoted
	result = css.ToCSSValue(token.TypeFontFamily, `"Roboto"`)
	expected = `"Roboto"`
	if result != expected {
		t.Errorf("expected %q, got %q", expected, result)
	}
}
