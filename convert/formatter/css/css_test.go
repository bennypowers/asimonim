/*
Copyright 2026 Benny Powers. All rights reserved.
Use of this source code is governed by the GPLv3
license that can be found in the LICENSE file.
*/

package css_test

import (
	"strings"
	"testing"

	"bennypowers.dev/asimonim/convert/formatter"
	"bennypowers.dev/asimonim/convert/formatter/css"
	"bennypowers.dev/asimonim/token"
)

func TestFormat_Plain(t *testing.T) {
	tokens := []*token.Token{
		{
			Name:        "color-primary",
			Path:        []string{"color", "primary"},
			Type:        token.TypeColor,
			Value:       "#FF6B35",
			Description: "Primary brand color",
		},
		{
			Name:  "spacing-small",
			Path:  []string{"spacing", "small"},
			Type:  token.TypeDimension,
			Value: "4px",
		},
	}

	f := css.New()
	result, err := f.Format(tokens, formatter.Options{})
	if err != nil {
		t.Fatalf("Format() error = %v", err)
	}

	output := string(result)

	// Check header
	if !strings.Contains(output, "/* Generated by asimonim */") {
		t.Error("expected header comment")
	}

	// Check :root selector
	if !strings.Contains(output, ":root {") {
		t.Error("expected :root selector")
	}

	// Check custom properties
	if !strings.Contains(output, "--color-primary: #FF6B35;") {
		t.Error("expected --color-primary custom property")
	}
	if !strings.Contains(output, "--spacing-small: 4px;") {
		t.Error("expected --spacing-small custom property")
	}

	// Check description comment
	if !strings.Contains(output, "/* Primary brand color */") {
		t.Error("expected description comment")
	}
}

func TestFormat_WithPrefix(t *testing.T) {
	tokens := []*token.Token{
		{
			Name:  "color-primary",
			Path:  []string{"color", "primary"},
			Type:  token.TypeColor,
			Value: "#FF6B35",
		},
	}

	f := css.New()
	result, err := f.Format(tokens, formatter.Options{Prefix: "rh"})
	if err != nil {
		t.Fatalf("Format() error = %v", err)
	}

	output := string(result)

	if !strings.Contains(output, "--rh-color-primary: #FF6B35;") {
		t.Error("expected prefixed custom property")
	}
}

func TestFormat_LitFlavor(t *testing.T) {
	tokens := []*token.Token{
		{
			Name:  "color-primary",
			Path:  []string{"color", "primary"},
			Type:  token.TypeColor,
			Value: "#FF6B35",
		},
	}

	f := css.NewWithFlavor(css.FlavorLit)
	result, err := f.Format(tokens, formatter.Options{})
	if err != nil {
		t.Fatalf("Format() error = %v", err)
	}

	output := string(result)

	// Check Lit import
	if !strings.Contains(output, "import { css } from 'lit';") {
		t.Error("expected Lit import")
	}

	// Check css template tag
	if !strings.Contains(output, "export default css`") {
		t.Error("expected css template tag export")
	}

	// Check :host selector (not :root for web components)
	if !strings.Contains(output, ":host {") {
		t.Error("expected :host selector for Lit")
	}

	// Check closing backtick
	if !strings.Contains(output, "`;") {
		t.Error("expected closing template backtick")
	}
}

func TestFormat_HostFlavor(t *testing.T) {
	tokens := []*token.Token{
		{
			Name:  "color-primary",
			Path:  []string{"color", "primary"},
			Type:  token.TypeColor,
			Value: "#FF6B35",
		},
	}

	f := css.NewWithFlavor(css.FlavorHost)
	result, err := f.Format(tokens, formatter.Options{})
	if err != nil {
		t.Fatalf("Format() error = %v", err)
	}

	output := string(result)

	// Check :host selector
	if !strings.Contains(output, ":host {") {
		t.Error("expected :host selector")
	}

	// Should have header but no Lit import
	if !strings.Contains(output, "/* Generated by asimonim */") {
		t.Error("expected header comment")
	}
	if strings.Contains(output, "import { css }") {
		t.Error("should not have Lit import for host flavor")
	}
}

func TestToCSSValue_CubicBezier(t *testing.T) {
	value := []any{0.25, 0.1, 0.25, 1.0}
	result := css.ToCSSValue(token.TypeCubicBezier, value)

	expected := "cubic-bezier(0.25, 0.1, 0.25, 1)"
	if result != expected {
		t.Errorf("expected %q, got %q", expected, result)
	}
}

func TestToCSSValue_FontFamily(t *testing.T) {
	result := css.ToCSSValue(token.TypeFontFamily, "Open Sans")
	expected := `"Open Sans"`
	if result != expected {
		t.Errorf("expected %q, got %q", expected, result)
	}

	// Already quoted
	result = css.ToCSSValue(token.TypeFontFamily, `"Roboto"`)
	expected = `"Roboto"`
	if result != expected {
		t.Errorf("expected %q, got %q", expected, result)
	}
}

func TestToCSSValue_Number(t *testing.T) {
	// Integer-like float
	result := css.ToCSSValue(token.TypeNumber, 400.0)
	if result != "400" {
		t.Errorf("expected \"400\", got %q", result)
	}

	// Actual float
	result = css.ToCSSValue(token.TypeNumber, 1.5)
	if result != "1.5" {
		t.Errorf("expected \"1.5\", got %q", result)
	}
}

func TestToCSSValue_Duration(t *testing.T) {
	// Milliseconds
	result := css.ToCSSValue("", "200ms")
	if result != "200ms" {
		t.Errorf("expected \"200ms\", got %q", result)
	}

	// Seconds
	result = css.ToCSSValue("", "0.5s")
	if result != "0.5s" {
		t.Errorf("expected \"0.5s\", got %q", result)
	}
}
