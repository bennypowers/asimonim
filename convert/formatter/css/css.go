/*
Copyright 2026 Benny Powers. All rights reserved.
Use of this source code is governed by the GPLv3
license that can be found in the LICENSE file.
*/

// Package css provides CSS custom property formatting for design tokens.
package css

import (
	"fmt"
	"regexp"
	"strings"

	"bennypowers.dev/asimonim/convert/formatter"
	"bennypowers.dev/asimonim/token"
)

// Selector specifies the CSS selector for custom properties.
type Selector string

const (
	// SelectorRoot uses :root selector (default, document-level).
	SelectorRoot Selector = ":root"
	// SelectorHost uses :host selector (shadow DOM components).
	SelectorHost Selector = ":host"
)

// Module specifies the JavaScript module wrapper for CSS output.
type Module string

const (
	// ModuleNone outputs plain CSS with no module wrapper.
	ModuleNone Module = ""
	// ModuleLit wraps CSS in Lit's css tagged template.
	ModuleLit Module = "lit"
)

// Options configures the CSS formatter.
type Options struct {
	formatter.Options

	// Selector controls the CSS selector (:root or :host).
	// Defaults to :root if empty.
	Selector Selector

	// Module controls the JavaScript module wrapper.
	// Empty string means plain CSS output.
	Module Module
}

// secondsDurationPattern matches duration values like "2s", "0.5s", "-1.5s".
var secondsDurationPattern = regexp.MustCompile(`^[+-]?\d+(\.\d+)?s$`)

// Formatter outputs CSS custom properties.
type Formatter struct {
	opts Options
}

// New creates a new CSS formatter with default options.
func New() *Formatter {
	return &Formatter{opts: Options{Selector: SelectorRoot}}
}

// NewWithOptions creates a new CSS formatter with the specified options.
func NewWithOptions(opts Options) *Formatter {
	// Default selector to :root if not specified
	if opts.Selector == "" {
		opts.Selector = SelectorRoot
	}
	return &Formatter{opts: opts}
}

// Format converts tokens to CSS custom properties.
func (f *Formatter) Format(tokens []*token.Token, opts formatter.Options) ([]byte, error) {
	var sb strings.Builder

	selector := f.opts.Selector
	if selector == "" {
		selector = SelectorRoot
	}

	// Write header/preamble
	switch f.opts.Module {
	case ModuleLit:
		sb.WriteString("import { css } from 'lit';\n\n")
		sb.WriteString("export default css`\n")
	default:
		sb.WriteString("/* Generated by asimonim */\n")
		sb.WriteString("/* Do not edit manually */\n\n")
	}

	// Write selector
	fmt.Fprintf(&sb, "%s {\n", selector)

	sorted := formatter.SortTokens(tokens)

	for _, tok := range sorted {
		baseName := formatter.ToKebabCase(strings.Join(tok.Path, "-"))
		name := formatter.ApplyPrefix(baseName, opts.Prefix, "-")

		value := formatter.ResolvedValue(tok)
		cssValue := ToCSSValue(tok.Type, value)

		if tok.Description != "" {
			fmt.Fprintf(&sb, "  /* %s */\n", tok.Description)
		}
		fmt.Fprintf(&sb, "  --%s: %s;\n", name, cssValue)
	}

	sb.WriteString("}\n")

	// Write module closing
	if f.opts.Module == ModuleLit {
		sb.WriteString("`;\n")
	}

	return []byte(sb.String()), nil
}

// ToCSSValue converts a token value to a CSS-compatible string.
func ToCSSValue(tokenType string, value any) string {
	switch tokenType {
	case token.TypeColor:
		return fmt.Sprintf("%v", value)
	case token.TypeDimension:
		return fmt.Sprintf("%v", value)
	case token.TypeNumber, token.TypeFontWeight:
		switch v := value.(type) {
		case float64:
			if v == float64(int(v)) {
				return fmt.Sprintf("%d", int(v))
			}
			return fmt.Sprintf("%g", v)
		case int:
			return fmt.Sprintf("%d", v)
		}
		return fmt.Sprintf("%v", value)
	case token.TypeFontFamily:
		if s, ok := value.(string); ok {
			// Quote font names with spaces
			if strings.Contains(s, " ") && !strings.HasPrefix(s, "\"") && !strings.HasPrefix(s, "'") {
				return fmt.Sprintf("%q", s)
			}
			return s
		}
	case token.TypeCubicBezier:
		if arr, ok := value.([]any); ok && len(arr) == 4 {
			return fmt.Sprintf("cubic-bezier(%v, %v, %v, %v)", arr[0], arr[1], arr[2], arr[3])
		}
	}

	if s, ok := value.(string); ok {
		// Values that are already valid CSS
		if strings.HasPrefix(s, "#") || strings.HasSuffix(s, "px") ||
			strings.HasSuffix(s, "rem") || strings.HasSuffix(s, "em") ||
			strings.HasSuffix(s, "%") || strings.HasSuffix(s, "ms") ||
			strings.HasSuffix(s, "vw") || strings.HasSuffix(s, "vh") ||
			strings.HasSuffix(s, "deg") || strings.HasSuffix(s, "rad") ||
			secondsDurationPattern.MatchString(s) {
			return s
		}
	}

	return fmt.Sprintf("%v", value)
}
