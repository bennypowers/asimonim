/*
Copyright 2026 Benny Powers. All rights reserved.
Use of this source code is governed by the GPLv3
license that can be found in the LICENSE file.
*/

// Package css provides CSS custom property formatting for design tokens.
package css

import (
	"fmt"
	"regexp"
	"strings"

	"bennypowers.dev/asimonim/convert/formatter"
	"bennypowers.dev/asimonim/token"
)

// Flavor specifies the output flavor for CSS formatting.
type Flavor int

const (
	// FlavorPlain outputs plain CSS with :root selector.
	FlavorPlain Flavor = iota
	// FlavorLit outputs CSS wrapped in Lit's css template tag.
	FlavorLit
	// FlavorHost outputs CSS with :host selector (for web components).
	FlavorHost
)

// Options configures the CSS formatter.
type Options struct {
	formatter.Options

	// Flavor controls the output style (plain, lit, host).
	Flavor Flavor
}

// secondsDurationPattern matches duration values like "2s", "0.5s", "-1.5s".
var secondsDurationPattern = regexp.MustCompile(`^[+-]?\d+(\.\d+)?s$`)

// Formatter outputs CSS custom properties.
type Formatter struct {
	opts Options
}

// New creates a new CSS formatter with default options.
func New() *Formatter {
	return &Formatter{opts: Options{Flavor: FlavorPlain}}
}

// NewWithOptions creates a new CSS formatter with the specified options.
func NewWithOptions(opts Options) *Formatter {
	return &Formatter{opts: opts}
}

// NewWithFlavor creates a new CSS formatter with the specified flavor.
func NewWithFlavor(flavor Flavor) *Formatter {
	return &Formatter{opts: Options{Flavor: flavor}}
}

// Format converts tokens to CSS custom properties.
func (f *Formatter) Format(tokens []*token.Token, opts formatter.Options) ([]byte, error) {
	var sb strings.Builder

	switch f.opts.Flavor {
	case FlavorLit:
		sb.WriteString("import { css } from 'lit';\n\n")
		sb.WriteString("export default css`\n")
		sb.WriteString(":host {\n")
	case FlavorHost:
		sb.WriteString("/* Generated by asimonim */\n")
		sb.WriteString("/* Do not edit manually */\n\n")
		sb.WriteString(":host {\n")
	default:
		sb.WriteString("/* Generated by asimonim */\n")
		sb.WriteString("/* Do not edit manually */\n\n")
		sb.WriteString(":root {\n")
	}

	sorted := formatter.SortTokens(tokens)

	for _, tok := range sorted {
		baseName := formatter.ToKebabCase(strings.Join(tok.Path, "-"))
		name := formatter.ApplyPrefix(baseName, opts.Prefix, "-")

		value := formatter.ResolvedValue(tok)
		cssValue := ToCSSValue(tok.Type, value)

		if tok.Description != "" {
			fmt.Fprintf(&sb, "  /* %s */\n", tok.Description)
		}
		fmt.Fprintf(&sb, "  --%s: %s;\n", name, cssValue)
	}

	sb.WriteString("}\n")

	if f.opts.Flavor == FlavorLit {
		sb.WriteString("`;\n")
	}

	return []byte(sb.String()), nil
}

// ToCSSValue converts a token value to a CSS-compatible string.
func ToCSSValue(tokenType string, value any) string {
	switch tokenType {
	case token.TypeColor:
		return fmt.Sprintf("%v", value)
	case token.TypeDimension:
		return fmt.Sprintf("%v", value)
	case token.TypeNumber, token.TypeFontWeight:
		switch v := value.(type) {
		case float64:
			if v == float64(int(v)) {
				return fmt.Sprintf("%d", int(v))
			}
			return fmt.Sprintf("%g", v)
		case int:
			return fmt.Sprintf("%d", v)
		}
		return fmt.Sprintf("%v", value)
	case token.TypeFontFamily:
		if s, ok := value.(string); ok {
			// Quote font names with spaces
			if strings.Contains(s, " ") && !strings.HasPrefix(s, "\"") && !strings.HasPrefix(s, "'") {
				return fmt.Sprintf("%q", s)
			}
			return s
		}
	case token.TypeCubicBezier:
		if arr, ok := value.([]any); ok && len(arr) == 4 {
			return fmt.Sprintf("cubic-bezier(%v, %v, %v, %v)", arr[0], arr[1], arr[2], arr[3])
		}
	}

	if s, ok := value.(string); ok {
		// Values that are already valid CSS
		if strings.HasPrefix(s, "#") || strings.HasSuffix(s, "px") ||
			strings.HasSuffix(s, "rem") || strings.HasSuffix(s, "em") ||
			strings.HasSuffix(s, "%") || strings.HasSuffix(s, "ms") ||
			strings.HasSuffix(s, "vw") || strings.HasSuffix(s, "vh") ||
			strings.HasSuffix(s, "deg") || strings.HasSuffix(s, "rad") ||
			secondsDurationPattern.MatchString(s) {
			return s
		}
	}

	return fmt.Sprintf("%v", value)
}
