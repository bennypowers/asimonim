/*
Copyright 2026 Benny Powers. All rights reserved.
Use of this source code is governed by the GPLv3
license that can be found in the LICENSE file.
*/

package convert

import (
	"encoding/json"
	"fmt"
	"sort"
	"strings"
	"unicode"

	"github.com/mazznoer/csscolorparser"

	"bennypowers.dev/asimonim/token"
)

// Format represents an output format for token serialization.
type Format string

const (
	// FormatDTCG outputs DTCG-compliant JSON (default).
	FormatDTCG Format = "dtcg"

	// FormatFlatJSON outputs flat key-value JSON.
	FormatFlatJSON Format = "json"

	// FormatAndroid outputs Android-style XML resources.
	FormatAndroid Format = "android"

	// FormatSwift outputs iOS Swift constants.
	FormatSwift Format = "swift"

	// FormatTypeScript outputs a TypeScript ESM module with camelCase exports.
	FormatTypeScript Format = "typescript"

	// FormatCTS outputs a TypeScript CommonJS module with camelCase exports.
	FormatCTS Format = "cts"

	// FormatSCSS outputs SCSS variables with kebab-case names.
	FormatSCSS Format = "scss"

	// FormatTailwind outputs a Tailwind theme configuration.
	FormatTailwind Format = "tailwind"
)

// ValidFormats returns all valid format strings.
func ValidFormats() []string {
	return []string{
		string(FormatDTCG),
		string(FormatFlatJSON),
		string(FormatAndroid),
		string(FormatSwift),
		string(FormatTypeScript),
		string(FormatCTS),
		string(FormatSCSS),
		string(FormatTailwind),
	}
}

// ParseFormat converts a string to a Format.
func ParseFormat(s string) (Format, error) {
	switch strings.ToLower(s) {
	case "dtcg", "":
		return FormatDTCG, nil
	case "json", "flat", "flat-json":
		return FormatFlatJSON, nil
	case "android", "xml":
		return FormatAndroid, nil
	case "swift", "ios":
		return FormatSwift, nil
	case "typescript", "ts":
		return FormatTypeScript, nil
	case "cts", "commonjs":
		return FormatCTS, nil
	case "scss", "sass":
		return FormatSCSS, nil
	case "tailwind", "tw":
		return FormatTailwind, nil
	default:
		return "", fmt.Errorf("unknown format: %s (valid: %s)", s, strings.Join(ValidFormats(), ", "))
	}
}

// FormatTokens converts tokens to the specified output format.
func FormatTokens(tokens []*token.Token, format Format, opts Options) ([]byte, error) {
	switch format {
	case FormatDTCG:
		result := Serialize(tokens, opts)
		return json.MarshalIndent(result, "", "  ")

	case FormatFlatJSON:
		return formatFlatJSON(tokens, opts)

	case FormatAndroid:
		return formatAndroid(tokens, opts)

	case FormatSwift:
		return formatSwift(tokens, opts)

	case FormatTypeScript:
		return formatTypeScript(tokens, opts)

	case FormatCTS:
		return formatCTS(tokens, opts)

	case FormatSCSS:
		return formatSCSS(tokens, opts)

	case FormatTailwind:
		return formatTailwind(tokens, opts)

	default:
		return nil, fmt.Errorf("unsupported format: %s", format)
	}
}

// formatFlatJSON outputs flat key-value JSON.
func formatFlatJSON(tokens []*token.Token, opts Options) ([]byte, error) {
	delimiter := opts.Delimiter
	if delimiter == "" {
		delimiter = "-"
	}

	result := make(map[string]any)
	for _, tok := range tokens {
		key := applyPrefix(strings.Join(tok.Path, delimiter), opts.Prefix, delimiter)
		result[key] = getResolvedValue(tok)
	}

	return json.MarshalIndent(result, "", "  ")
}

// applyPrefix adds a prefix to a name with the given delimiter.
func applyPrefix(name, prefix, delimiter string) string {
	if prefix == "" {
		return name
	}
	return prefix + delimiter + name
}

// formatAndroid outputs Android-style XML resources.
func formatAndroid(tokens []*token.Token, opts Options) ([]byte, error) {
	var sb strings.Builder
	sb.WriteString(`<?xml version="1.0" encoding="utf-8"?>`)
	sb.WriteString("\n<resources>\n")

	// Sort tokens for consistent output
	sorted := sortTokens(tokens)

	for _, tok := range sorted {
		baseName := toSnakeCase(strings.Join(tok.Path, "_"))
		name := applyPrefix(baseName, opts.Prefix, "_")
		value := getResolvedValue(tok)
		xmlType := getXMLType(tok.Type)

		sb.WriteString(fmt.Sprintf("    <%s name=\"%s\">%s</%s>\n",
			xmlType, name, escapeXML(fmt.Sprintf("%v", value)), xmlType))
	}

	sb.WriteString("</resources>\n")
	return []byte(sb.String()), nil
}

// formatSwift outputs iOS Swift constants.
func formatSwift(tokens []*token.Token, opts Options) ([]byte, error) {
	var sb strings.Builder
	sb.WriteString("import Foundation\n")
	sb.WriteString("import SwiftUI\n\n")
	sb.WriteString("// Generated by asimonim\n")
	sb.WriteString("// Do not edit manually\n\n")

	// Use prefix in enum name if provided
	enumName := "DesignTokens"
	if opts.Prefix != "" {
		enumName = toPascalCase(opts.Prefix) + "Tokens"
	}
	sb.WriteString(fmt.Sprintf("public enum %s {\n", enumName))

	// Group tokens by type
	groups := groupTokensByType(tokens)
	typeOrder := []string{"color", "dimension", "fontFamily", "fontWeight", "duration", "cubicBezier", "number", "string"}

	for _, tokenType := range typeOrder {
		group, exists := groups[tokenType]
		if !exists || len(group) == 0 {
			continue
		}

		sb.WriteString(fmt.Sprintf("\n    // MARK: - %s\n", toTitleCase(tokenType)))
		sb.WriteString(fmt.Sprintf("    public enum %s {\n", toPascalCase(tokenType)))

		sorted := sortTokens(group)
		for _, tok := range sorted {
			name := toCamelCase(strings.Join(tok.Path, "-"))
			value := getResolvedValue(tok)
			swiftValue := toSwiftValue(tok.Type, value)

			if tok.Description != "" {
				sb.WriteString(fmt.Sprintf("        /// %s\n", tok.Description))
			}
			sb.WriteString(fmt.Sprintf("        public static let %s = %s\n", name, swiftValue))
		}

		sb.WriteString("    }\n")
	}

	// Handle ungrouped tokens
	if ungrouped, exists := groups[""]; exists && len(ungrouped) > 0 {
		sb.WriteString("\n    // MARK: - Other\n")
		sb.WriteString("    public enum Other {\n")
		sorted := sortTokens(ungrouped)
		for _, tok := range sorted {
			name := toCamelCase(strings.Join(tok.Path, "-"))
			value := getResolvedValue(tok)
			sb.WriteString(fmt.Sprintf("        public static let %s = \"%v\"\n", name, value))
		}
		sb.WriteString("    }\n")
	}

	sb.WriteString("}\n")
	return []byte(sb.String()), nil
}

// formatTypeScript outputs a TypeScript module with camelCase exports.
// Uses 'as const' for literal types instead of explicit type annotations.
func formatTypeScript(tokens []*token.Token, opts Options) ([]byte, error) {
	var sb strings.Builder
	sb.WriteString("// Generated by asimonim\n")
	sb.WriteString("// Do not edit manually\n\n")

	sorted := sortTokens(tokens)

	for _, tok := range sorted {
		baseName := toCamelCase(strings.Join(tok.Path, "-"))
		name := applyPrefixCamel(baseName, opts.Prefix)
		value := getResolvedValue(tok)
		tsValue := toTypeScriptValue(value)

		if tok.Description != "" {
			sb.WriteString(fmt.Sprintf("/** %s */\n", tok.Description))
		}
		sb.WriteString(fmt.Sprintf("export const %s = %s as const;\n", name, tsValue))
	}

	return []byte(sb.String()), nil
}

// applyPrefixCamel applies a prefix in camelCase style.
func applyPrefixCamel(name, prefix string) string {
	if prefix == "" {
		return name
	}
	// Prefix becomes the start, name gets capitalized first letter
	return toCamelCase(prefix) + strings.ToUpper(name[:1]) + name[1:]
}

// formatCTS outputs a CommonJS TypeScript module with camelCase exports.
func formatCTS(tokens []*token.Token, opts Options) ([]byte, error) {
	var sb strings.Builder
	sb.WriteString("// Generated by asimonim\n")
	sb.WriteString("// Do not edit manually\n\n")

	sorted := sortTokens(tokens)

	for _, tok := range sorted {
		baseName := toCamelCase(strings.Join(tok.Path, "-"))
		name := applyPrefixCamel(baseName, opts.Prefix)
		value := getResolvedValue(tok)
		tsValue := toTypeScriptValue(value)

		if tok.Description != "" {
			sb.WriteString(fmt.Sprintf("/** %s */\n", tok.Description))
		}
		sb.WriteString(fmt.Sprintf("exports.%s = %s as const;\n", name, tsValue))
	}

	return []byte(sb.String()), nil
}

// formatSCSS outputs SCSS variables with kebab-case names.
func formatSCSS(tokens []*token.Token, opts Options) ([]byte, error) {
	var sb strings.Builder
	sb.WriteString("// Generated by asimonim\n")
	sb.WriteString("// Do not edit manually\n\n")

	// Group tokens by top-level path segment
	groups := make(map[string][]*token.Token)
	for _, tok := range tokens {
		if len(tok.Path) > 0 {
			groups[tok.Path[0]] = append(groups[tok.Path[0]], tok)
		}
	}

	// Get sorted group names
	var groupNames []string
	for name := range groups {
		groupNames = append(groupNames, name)
	}
	sort.Strings(groupNames)

	for _, groupName := range groupNames {
		group := groups[groupName]
		sb.WriteString(fmt.Sprintf("// %s\n", toTitleCase(groupName)))

		sorted := sortTokens(group)
		for _, tok := range sorted {
			baseName := toKebabCase(strings.Join(tok.Path, "-"))
			name := applyPrefix(baseName, opts.Prefix, "-")
			value := getResolvedValue(tok)
			scssValue := toSCSSValue(tok.Type, value)

			if tok.Description != "" {
				sb.WriteString(fmt.Sprintf("/// %s\n", tok.Description))
			}
			sb.WriteString(fmt.Sprintf("$%s: %s;\n", name, scssValue))
		}
		sb.WriteString("\n")
	}

	return []byte(sb.String()), nil
}

// formatTailwind outputs a Tailwind theme configuration.
// Note: prefix is not applied to Tailwind output as it uses its own structure.
func formatTailwind(tokens []*token.Token, opts Options) ([]byte, error) {
	_ = opts // prefix not applicable for Tailwind structure
	theme := make(map[string]any)

	for _, tok := range tokens {
		if len(tok.Path) == 0 {
			continue
		}

		// Map token types to Tailwind theme keys
		themeKey := mapToTailwindKey(tok.Type, tok.Path[0])
		if themeKey == "" {
			continue
		}

		// Build nested structure within theme key
		if _, exists := theme[themeKey]; !exists {
			theme[themeKey] = make(map[string]any)
		}

		// Use remaining path segments (skip first which is the group)
		var keyPath []string
		if len(tok.Path) > 1 {
			keyPath = tok.Path[1:]
		} else {
			keyPath = []string{"DEFAULT"}
		}

		current := theme[themeKey].(map[string]any)
		for i, segment := range keyPath {
			if i == len(keyPath)-1 {
				current[segment] = getResolvedValue(tok)
			} else {
				if _, exists := current[segment]; !exists {
					current[segment] = make(map[string]any)
				}
				current = current[segment].(map[string]any)
			}
		}
	}

	// Build final structure
	result := map[string]any{
		"theme": map[string]any{
			"extend": theme,
		},
	}

	output, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		return nil, err
	}

	// Add module.exports wrapper
	var sb strings.Builder
	sb.WriteString("// Generated by asimonim\n")
	sb.WriteString("// Do not edit manually\n\n")
	sb.WriteString("/** @type {import('tailwindcss').Config} */\n")
	sb.WriteString("module.exports = ")
	sb.Write(output)
	sb.WriteString(";\n")

	return []byte(sb.String()), nil
}

// Helper functions

func getResolvedValue(tok *token.Token) any {
	if tok.ResolvedValue != nil {
		return tok.ResolvedValue
	}
	if tok.RawValue != nil {
		return tok.RawValue
	}
	return tok.Value
}

func sortTokens(tokens []*token.Token) []*token.Token {
	sorted := make([]*token.Token, len(tokens))
	copy(sorted, tokens)
	sort.Slice(sorted, func(i, j int) bool {
		return sorted[i].Name < sorted[j].Name
	})
	return sorted
}

func groupTokensByType(tokens []*token.Token) map[string][]*token.Token {
	groups := make(map[string][]*token.Token)
	for _, tok := range tokens {
		groups[tok.Type] = append(groups[tok.Type], tok)
	}
	return groups
}

func toCamelCase(s string) string {
	words := splitIntoWords(s)
	if len(words) == 0 {
		return ""
	}

	result := strings.ToLower(words[0])
	for i := 1; i < len(words); i++ {
		if len(words[i]) > 0 {
			result += strings.ToUpper(words[i][:1]) + strings.ToLower(words[i][1:])
		}
	}
	return result
}

func toPascalCase(s string) string {
	words := splitIntoWords(s)
	var result string
	for _, word := range words {
		if len(word) > 0 {
			result += strings.ToUpper(word[:1]) + strings.ToLower(word[1:])
		}
	}
	return result
}

func toSnakeCase(s string) string {
	words := splitIntoWords(s)
	return strings.ToLower(strings.Join(words, "_"))
}

func toKebabCase(s string) string {
	words := splitIntoWords(s)
	return strings.ToLower(strings.Join(words, "-"))
}

func toTitleCase(s string) string {
	words := splitIntoWords(s)
	for i, word := range words {
		if len(word) > 0 {
			words[i] = strings.ToUpper(word[:1]) + strings.ToLower(word[1:])
		}
	}
	return strings.Join(words, " ")
}

func splitIntoWords(s string) []string {
	// Split on hyphens, underscores, dots, and camelCase boundaries
	var words []string
	var current strings.Builder

	for i, r := range s {
		if r == '-' || r == '_' || r == '.' || r == ' ' {
			if current.Len() > 0 {
				words = append(words, current.String())
				current.Reset()
			}
		} else if unicode.IsUpper(r) && i > 0 {
			if current.Len() > 0 {
				words = append(words, current.String())
				current.Reset()
			}
			current.WriteRune(r)
		} else {
			current.WriteRune(r)
		}
	}

	if current.Len() > 0 {
		words = append(words, current.String())
	}

	return words
}

func escapeXML(s string) string {
	s = strings.ReplaceAll(s, "&", "&amp;")
	s = strings.ReplaceAll(s, "<", "&lt;")
	s = strings.ReplaceAll(s, ">", "&gt;")
	s = strings.ReplaceAll(s, "\"", "&quot;")
	s = strings.ReplaceAll(s, "'", "&apos;")
	return s
}

func getXMLType(tokenType string) string {
	switch tokenType {
	case "color":
		return "color"
	case "dimension":
		return "dimen"
	case "number":
		return "integer"
	case "string", "fontFamily":
		return "string"
	default:
		return "string"
	}
}

func toTypeScriptValue(value any) string {
	switch v := value.(type) {
	case string:
		return fmt.Sprintf("%q", v)
	case float64:
		if v == float64(int(v)) {
			return fmt.Sprintf("%d", int(v))
		}
		return fmt.Sprintf("%g", v)
	case int:
		return fmt.Sprintf("%d", v)
	case bool:
		return fmt.Sprintf("%t", v)
	default:
		return fmt.Sprintf("%q", fmt.Sprintf("%v", v))
	}
}

func toSwiftValue(tokenType string, value any) string {
	switch tokenType {
	case "color":
		// Handle structured color objects (v2025_10 spec)
		if colorObj, ok := value.(map[string]any); ok {
			return structuredColorToSwift(colorObj)
		}
		// Handle string colors (draft spec)
		if s, ok := value.(string); ok {
			c, err := csscolorparser.Parse(s)
			if err == nil {
				return formatSwiftColor(".sRGB", c.R, c.G, c.B, c.A)
			}
			// Fallback to string if parsing fails
			return fmt.Sprintf("%q", s)
		}
	case "dimension":
		if s, ok := value.(string); ok {
			// Extract numeric value
			s = strings.TrimSuffix(s, "px")
			s = strings.TrimSuffix(s, "rem")
			s = strings.TrimSuffix(s, "em")
			return fmt.Sprintf("CGFloat(%s)", s)
		}
	case "duration":
		if s, ok := value.(string); ok {
			s = strings.TrimSuffix(s, "ms")
			s = strings.TrimSuffix(s, "s")
			return fmt.Sprintf("TimeInterval(%s)", s)
		}
	case "number", "fontWeight":
		switch v := value.(type) {
		case float64:
			if v == float64(int(v)) {
				return fmt.Sprintf("%d", int(v))
			}
			return fmt.Sprintf("%g", v)
		case int:
			return fmt.Sprintf("%d", v)
		}
	}

	// Default: string literal
	return fmt.Sprintf("%q", fmt.Sprintf("%v", value))
}

func toSCSSValue(tokenType string, value any) string {
	switch tokenType {
	case "color":
		return fmt.Sprintf("%v", value)
	case "dimension":
		return fmt.Sprintf("%v", value)
	case "number", "fontWeight":
		switch v := value.(type) {
		case float64:
			if v == float64(int(v)) {
				return fmt.Sprintf("%d", int(v))
			}
			return fmt.Sprintf("%g", v)
		case int:
			return fmt.Sprintf("%d", v)
		}
		return fmt.Sprintf("%v", value)
	case "fontFamily":
		if s, ok := value.(string); ok {
			// Quote font family names
			return fmt.Sprintf("%q", s)
		}
	}

	// Default handling
	if s, ok := value.(string); ok {
		// If it looks like a CSS value, don't quote it
		if strings.HasPrefix(s, "#") || strings.HasSuffix(s, "px") ||
			strings.HasSuffix(s, "rem") || strings.HasSuffix(s, "em") ||
			strings.HasSuffix(s, "%") || strings.HasSuffix(s, "ms") ||
			strings.HasSuffix(s, "s") {
			return s
		}
	}

	return fmt.Sprintf("%v", value)
}

func mapToTailwindKey(tokenType, pathFirst string) string {
	// First try by token type
	switch tokenType {
	case "color":
		return "colors"
	case "dimension":
		// Map based on path prefix
		switch pathFirst {
		case "spacing", "space", "gap":
			return "spacing"
		case "radius", "borderRadius":
			return "borderRadius"
		case "fontSize", "font-size":
			return "fontSize"
		case "lineHeight", "line-height":
			return "lineHeight"
		case "borderWidth", "border-width":
			return "borderWidth"
		default:
			return "spacing"
		}
	case "fontFamily":
		return "fontFamily"
	case "fontWeight":
		return "fontWeight"
	case "duration":
		return "transitionDuration"
	case "cubicBezier":
		return "transitionTimingFunction"
	case "shadow":
		return "boxShadow"
	}

	// Fallback: try to infer from path
	switch pathFirst {
	case "color", "colors":
		return "colors"
	case "spacing", "space":
		return "spacing"
	case "font", "typography":
		return "fontSize"
	default:
		return ""
	}
}

// structuredColorToSwift converts a v2025_10 structured color to SwiftUI Color.
func structuredColorToSwift(colorObj map[string]any) string {
	colorSpace, _ := colorObj["colorSpace"].(string)
	componentsRaw, _ := colorObj["components"].([]any)
	alphaRaw := colorObj["alpha"]

	// Get alpha (default 1.0)
	alpha := 1.0
	if a, ok := alphaRaw.(float64); ok {
		alpha = a
	}

	// Get components
	var components []float64
	for _, comp := range componentsRaw {
		if v, ok := comp.(float64); ok {
			components = append(components, v)
		}
	}

	// Need at least 3 components for RGB
	if len(components) < 3 {
		return `""`
	}

	// Map DTCG colorspace to SwiftUI colorspace
	swiftColorSpace := mapColorSpaceToSwift(colorSpace)

	return formatSwiftColor(swiftColorSpace, components[0], components[1], components[2], alpha)
}

// mapColorSpaceToSwift maps DTCG colorspace names to SwiftUI CGColorSpace names.
func mapColorSpaceToSwift(dtcgColorSpace string) string {
	switch dtcgColorSpace {
	case "srgb", "":
		return ".sRGB"
	case "display-p3":
		return ".displayP3"
	case "srgb-linear", "linear-srgb":
		return ".linearSRGB"
	case "xyz", "xyz-d65":
		return ".genericXYZ"
	case "xyz-d50":
		// SwiftUI doesn't have D50 XYZ, use generic XYZ
		return ".genericXYZ"
	case "lab", "lch", "oklab", "oklch":
		// Lab/LCH colorspaces not directly supported in SwiftUI
		// Fall back to sRGB (caller should convert if needed)
		return ".sRGB"
	default:
		return ".sRGB"
	}
}

// formatSwiftColor formats RGB(A) values as a SwiftUI Color constructor.
func formatSwiftColor(colorSpace string, r, g, b, a float64) string {
	if a < 0.999 {
		return fmt.Sprintf("Color(%s, red: %.4g, green: %.4g, blue: %.4g, opacity: %.4g)", colorSpace, r, g, b, a)
	}
	return fmt.Sprintf("Color(%s, red: %.4g, green: %.4g, blue: %.4g)", colorSpace, r, g, b)
}
