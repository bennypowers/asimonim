/*
Copyright 2026 Benny Powers. All rights reserved.
Use of this source code is governed by the GPLv3
license that can be found in the LICENSE file.
*/

package specifier

import (
	"fmt"
	"path/filepath"
	"strings"

	asimfs "bennypowers.dev/asimonim/fs"
)

// NodeModulesResolver resolves npm: specifiers by walking the filesystem
// to find node_modules directories.
type NodeModulesResolver struct {
	fs      asimfs.FileSystem
	rootDir string
}

// NewNodeModulesResolver creates a resolver for npm: package specifiers.
// The rootDir must be an absolute path - this is required for compatibility
// with virtual/in-memory filesystems that don't have a working directory concept.
func NewNodeModulesResolver(fs asimfs.FileSystem, rootDir string) (*NodeModulesResolver, error) {
	if !filepath.IsAbs(rootDir) {
		return nil, fmt.Errorf("rootDir must be an absolute path, got: %s", rootDir)
	}
	return &NodeModulesResolver{
		fs:      fs,
		rootDir: rootDir,
	}, nil
}

// Resolve resolves an npm: specifier to a filesystem path.
// It walks up the directory tree looking for node_modules.
func (r *NodeModulesResolver) Resolve(spec string) (*ResolvedFile, error) {
	parsed := Parse(spec)
	if parsed.Kind != KindNPM {
		return nil, fmt.Errorf("not an npm specifier: %s", spec)
	}

	// rootDir is guaranteed absolute by constructor
	dir := r.rootDir
	startDir := dir

	// Walk up directory tree looking for node_modules
	for {
		nodeModulesBase := filepath.Join(dir, "node_modules")
		nodeModulesPath := filepath.Clean(filepath.Join(nodeModulesBase, parsed.Package, parsed.File))

		// Path traversal protection: verify path stays inside node_modules
		if !isInsideDir(nodeModulesPath, nodeModulesBase) {
			return nil, fmt.Errorf("path traversal detected in specifier: %s", spec)
		}

		if r.fs.Exists(nodeModulesPath) {
			return &ResolvedFile{
				Specifier: spec,
				Path:      nodeModulesPath,
				Kind:      KindNPM,
			}, nil
		}

		// Move up one directory
		parent := filepath.Dir(dir)
		if parent == dir {
			// Reached filesystem root
			break
		}
		dir = parent
	}

	return nil, fmt.Errorf("package not found: %s (looked in node_modules starting from %s)", parsed.Package, startDir)
}

// isInsideDir checks if path is inside baseDir (no path traversal escape).
func isInsideDir(path, baseDir string) bool {
	rel, err := filepath.Rel(baseDir, path)
	if err != nil {
		return false
	}
	// Reject if relative path escapes via ".." or is absolute
	if strings.HasPrefix(rel, "..") || filepath.IsAbs(rel) {
		return false
	}
	return true
}

// CanResolve returns true for npm: specifiers.
func (r *NodeModulesResolver) CanResolve(spec string) bool {
	return strings.HasPrefix(spec, "npm:")
}
